<HTML>
<HEAD>
<TITLE>Convert::ASN1 - ASN.1 Encode/Decode library</TITLE>
<LINK REV="made" HREF="mailto:feedback@suse.de">
</HEAD>

<BODY>

<!-- INDEX BEGIN -->
<!--

<UL>

	<LI><A HREF="#NAME">NAME</A>
	<LI><A HREF="#SYNOPSYS">SYNOPSYS</A>
	<LI><A HREF="#DESCRIPTION">DESCRIPTION</A>
	<LI><A HREF="#METHODS">METHODS</A>
	<UL>

		<LI><A HREF="#new">new</A>
		<LI><A HREF="#error">error</A>
		<LI><A HREF="#configure_OPTIONS_">configure ( OPTIONS )</A>
		<LI><A HREF="#prepare_ASN_">prepare ( ASN )</A>
		<LI><A HREF="#find_MACRO_">find ( MACRO )</A>
		<LI><A HREF="#encode_VARIABLES_">encode ( VARIABLES )</A>
		<LI><A HREF="#decode_PDU_">decode ( PDU )</A>
	</UL>

	<LI><A HREF="#EXPORTS">EXPORTS</A>
	<UL>

		<LI><A HREF="#IO_Functions">IO Functions</A>
		<LI><A HREF="#Encode_Decode_Functions">Encode/Decode Functions</A>
		<LI><A HREF="#Constants">Constants</A>
		<LI><A HREF="#Debug_Functions">Debug Functions</A>
	</UL>

	<LI><A HREF="#EXPORT_TAGS">EXPORT TAGS</A>
	<LI><A HREF="#MAPPING_ASN_1_TO_PERL">MAPPING ASN.1 TO PERL</A>
	<UL>

		<LI><A HREF="#Exceptions">Exceptions</A>
	</UL>

	<LI><A HREF="#TODO">TODO</A>
	<LI><A HREF="#AUTHOR">AUTHOR</A>
	<LI><A HREF="#COPYRIGHT">COPYRIGHT</A>
</UL>
-->
<!-- INDEX END -->

<P>
<H1><A NAME="NAME">NAME</A></H1>
<P>
<PRE>  Convert::ASN1 - ASN.1 Encode/Decode library
</PRE>
<P>
<HR>
<H1><A NAME="SYNOPSYS">SYNOPSYS</A></H1>
<P>
<PRE>  use Convert::ASN1;
</PRE>
<P>
<PRE>  $asn = Convert::ASN1-&gt;new;
  $asn-&gt;prepare(q&lt;
</PRE>
<P>
<PRE>    [APPLICATION 7] SEQUENCE {
      int INTEGER,
      str OCTET STRING
    }
</PRE>
<P>
<PRE>  &gt;);
</PRE>
<P>
<PRE>  $pdu = $asn-&gt;encode( int =&gt; 7, str =&gt; &quot;string&quot;);
</PRE>
<P>
<PRE>  $out = $asn-&gt;decode($pdu);
  print $out-&gt;{int},&quot; &quot;,$out-&gt;{str},&quot;\n&quot;;
</PRE>
<P>
<PRE>  use Convert::ASN1 qw(:io);
</PRE>
<P>
<PRE>  $peer   = asn_recv($sock,$buffer,0);
  $nbytes = asn_read($fh, $buffer);
  $nbytes = asn_send($sock, $buffer, $peer);
  $nbytes = asn_send($sock, $buffer);
  $nbytes = asn_write($fh, $buffer);
  $buffer = asn_get($fh);
  $yes    = asn_ready($fh)
</PRE>
<P>
<HR>
<H1><A NAME="DESCRIPTION">DESCRIPTION</A></H1>
<P>
Convert::ASN1 encodes and decodes ASN.1 data structures using BER/DER
rules.

<P>
<HR>
<H1><A NAME="METHODS">METHODS</A></H1>
<P>
<HR>
<H2><A NAME="new">new</A></H2>
<P>
Contructor, creates a new object.

<P>
<HR>
<H2><A NAME="error">error</A></H2>
<P>
Returns the last error.

<P>
<HR>
<H2><A NAME="configure_OPTIONS_">configure ( OPTIONS )</A></H2>
<P>
Configure options to control how Convert::ASN1 will perform various tasks.
Options are passed as name-value pairs.

<DL>
<DT><STRONG><A NAME="item_encode">encode</A></STRONG><DD>
<P>
Reference to a hash which contains various encode options.

<DT><STRONG><A NAME="item_decode">decode</A></STRONG><DD>
<P>
Reference to a hash which contains various decode options.

<DT><STRONG><A NAME="item_encoding">encoding</A></STRONG><DD>
<P>
One of 'ber', 'der', 'per'. <EM>Currently not used</EM>



</DL>
<P>
Encode options

<DL>
<DT><STRONG><A NAME="item_real">real</A></STRONG><DD>
<P>
Which encoding to use for real's. One of 'binary', 'nr1', 'nr2', 'nr3'

<DT><STRONG><A NAME="item_time">time</A></STRONG><DD>
<P>
This controls how UTCTime and GeneralizedTime elements are encoded. The
default is <A HREF="#item_withzone">withzone</A>.

<DL>
<DT><STRONG><A NAME="item_utctime">utctime</A></STRONG><DD>
<P>
The value passed will be encoded without a zone, ie a UTC value.

<DT><STRONG><A NAME="item_withzone">withzone</A></STRONG><DD>
<P>
The value will be encoded with a zone. By default it will be encoded using
the local time offset. The offset may be set using the <A HREF="#item_timezone">timezone</A>
configure option.

<DT><STRONG><A NAME="item_raw">raw</A></STRONG><DD>
<P>
The value passed should already be in the correct format and will be copied
into the PDU as-is.

</DL>
<DT><STRONG><A NAME="item_timezone">timezone</A></STRONG><DD>
<P>
By default UTCTime and GeneralizedTime will be encoded using the local time
offset from UTC. This will over-ride that. It is an offset from UTC in
seconds. This option can be overriden by passing a reference to a list of
two values as the time value. The list should contain the time value and
the offset from UTC in seconds.

</DL>
<P>
Decode options

<DL>
<DT><STRONG>time</STRONG><DD>
<P>
This controls how a UTCTime or a GeneralizedTime element will be decoded.
The default is <A HREF="#item_utctime">utctime</A>.

<DL>
<DT><STRONG>utctime</STRONG><DD>
<P>
The value returned will be a time value as returned by the <A HREF="#item_time">time</A> function.

<DT><STRONG>withzone</STRONG><DD>
<P>
The value returned will be a reference to an array of two values. The first
is the same as with <A HREF="#item_utctime">utctime</A>, the second is the timezone offset, in seconds, that was used in the
encoding.

<DT><STRONG>raw</STRONG><DD>
<P>
The value returned will be the raw encoding as extracted from the PDU.

</DL>
</DL>
<P>
<HR>
<H2><A NAME="prepare_ASN_">prepare ( ASN )</A></H2>
<P>
Compile the given ASN.1 descripton. The syntax used is very close to ASN.1,
but has a few differnces. If the ASN decribes only one macro then
encode/decode can be called on this object. If ASN describes more than one
ASN.1 macro then <CODE>find</CODE>
must be called.

<P>
<HR>
<H2><A NAME="find_MACRO_">find ( MACRO )</A></H2>
<P>
Find a macro froma prepared ASN.1 description. Returns an object which can
be used for encode/decode.

<P>
<HR>
<H2><A NAME="encode_VARIABLES_">encode ( VARIABLES )</A></H2>
<P>
Encode a PDU. Top-level variable are passed as name-value pairs, or as a
reference to a hash containing them. Returns the encoded PDU, or undef on
error.

<P>
<HR>
<H2><A NAME="decode_PDU_">decode ( PDU )</A></H2>
<P>
Decode the PDU, returns a reference to a hash containg the values for the
PDU. Returns undef if there was an error.

<P>
<HR>
<H1><A NAME="EXPORTS">EXPORTS</A></H1>
<P>
As well as providing an object interface for encoding/decoding PDUs
Convert::ASN1 also provides the follow functions.

<P>
<HR>
<H2><A NAME="IO_Functions">IO Functions</A></H2>
<DL>
<DT><STRONG><A NAME="item_asn_recv">asn_recv SOCK, BUFFER, FLAGS</A></STRONG><DD>
<P>
Will read a single element from the socket SOCK into BUFFER. FLAGS may be
MSG_PEEK as exported by <CODE>Socket</CODE>. Returns the address of the sender, or undef if there was an error. Some
systems do not support the return of the peer address when the socket is a
connected socket, in these cases the empty string will be returned. This is
the same behaviour as the <CODE>recv</CODE> function in perl itself.

<P>
It is reccomended that if the socket is of type SOCK_DGRAM then <CODE>recv</CODE>
be called directly instead of calling <A HREF="#item_asn_recv">asn_recv</A>.

<DT><STRONG><A NAME="item_asn_read">asn_read FH, BUFFER, OFFSET</A></STRONG><DD>
<DT><STRONG>asn_read FH, BUFFER</STRONG><DD>
<P>
Will read a single element from the filehandle FH into BUFFER. Returns the
number of bytes read if a complete element was read, -1 if an incomplete
element was read or undef if there was an error. If OFFSET is specified
then it is assumed that BUFFER already contains an incomplete element and
new data will be appended starting at OFFSET.

<P>
If FH is a socket the asn_recv is used to read the element, so the same
restiction applies if FH is a socket of type SOCK_DGRAM.

<DT><STRONG><A NAME="item_asn_send">asn_send SOCK, BUFFER, FLAGS, TO</A></STRONG><DD>
<DT><STRONG>asn_send SOCK, BUFFER, FLAGS</STRONG><DD>
<P>
Identical to calling <CODE>send</CODE>, see <EM>perlfunc</EM>



<DT><STRONG><A NAME="item_asn_write">asn_write FH, BUFFER</A></STRONG><DD>
<P>
Identical to calling <CODE>syswrite</CODE> with 2 arguments, see <EM>perlfunc</EM>



<DT><STRONG><A NAME="item_asn_get">asn_get FH</A></STRONG><DD>
<P>
<A HREF="#item_asn_get">asn_get</A> provides buffered IO. Because it needs a buffer FH must be a GLOB or a
reference to a GLOB. <A HREF="#item_asn_get">asn_get</A> will use two entries in the hash element of the GLOB to use as it's buffer

<P>
<PRE>  asn_buffer - input buffer
  asn_need   - number of bytes needed for the next element, if known
</PRE>
<P>
Returns an element or undef if there was an error.

<DT><STRONG><A NAME="item_asn_ready">asn_ready FH</A></STRONG><DD>
<P>
<A HREF="#item_asn_ready">asn_ready</A> works with <A HREF="#item_asn_get">asn_get</A>. It will return true if <A HREF="#item_asn_get">asn_get</A> has already read enough data into the buffer to return a complete element.

</DL>
<P>
<HR>
<H2><A NAME="Encode_Decode_Functions">Encode/Decode Functions</A></H2>
<DL>
<DT><STRONG><A NAME="item_asn_tag">asn_tag</A></STRONG><DD>
<DT><STRONG><A NAME="item_asn_decode_tag">asn_decode_tag</A></STRONG><DD>
<DT><STRONG><A NAME="item_asn_encode_tag">asn_encode_tag</A></STRONG><DD>
<DT><STRONG><A NAME="item_asn_decode_length">asn_decode_length</A></STRONG><DD>
<DT><STRONG><A NAME="item_asn_encode_length">asn_encode_length</A></STRONG><DD>
</DL>
<P>
<HR>
<H2><A NAME="Constants">Constants</A></H2>
<DL>
<DT><STRONG><A NAME="item_ASN_BIT_STR">ASN_BIT_STR</A></STRONG><DD>
<DT><STRONG><A NAME="item_ASN_BOOLEAN">ASN_BOOLEAN</A></STRONG><DD>
<DT><STRONG><A NAME="item_ASN_ENUMERATED">ASN_ENUMERATED</A></STRONG><DD>
<DT><STRONG><A NAME="item_ASN_GENERAL_TIME">ASN_GENERAL_TIME</A></STRONG><DD>
<DT><STRONG><A NAME="item_ASN_IA5_STR">ASN_IA5_STR</A></STRONG><DD>
<DT><STRONG><A NAME="item_ASN_INTEGER">ASN_INTEGER</A></STRONG><DD>
<DT><STRONG><A NAME="item_ASN_NULL">ASN_NULL</A></STRONG><DD>
<DT><STRONG><A NAME="item_ASN_OBJECT_ID">ASN_OBJECT_ID</A></STRONG><DD>
<DT><STRONG><A NAME="item_ASN_OCTET_STR">ASN_OCTET_STR</A></STRONG><DD>
<DT><STRONG><A NAME="item_ASN_PRINT_STR">ASN_PRINT_STR</A></STRONG><DD>
<DT><STRONG><A NAME="item_ASN_REAL">ASN_REAL</A></STRONG><DD>
<DT><STRONG><A NAME="item_ASN_SEQUENCE">ASN_SEQUENCE</A></STRONG><DD>
<DT><STRONG><A NAME="item_ASN_SET">ASN_SET</A></STRONG><DD>
<DT><STRONG><A NAME="item_ASN_UTC_TIME">ASN_UTC_TIME</A></STRONG><DD>
<DT><STRONG><A NAME="item_ASN_APPLICATION">ASN_APPLICATION</A></STRONG><DD>
<DT><STRONG><A NAME="item_ASN_CONTEXT">ASN_CONTEXT</A></STRONG><DD>
<DT><STRONG><A NAME="item_ASN_PRIVATE">ASN_PRIVATE</A></STRONG><DD>
<DT><STRONG><A NAME="item_ASN_UNIVERSAL">ASN_UNIVERSAL</A></STRONG><DD>
<DT><STRONG><A NAME="item_ASN_PRIMITIVE">ASN_PRIMITIVE</A></STRONG><DD>
<DT><STRONG><A NAME="item_ASN_CONSTRUCTOR">ASN_CONSTRUCTOR</A></STRONG><DD>
<DT><STRONG><A NAME="item_ASN_LONG_LEN">ASN_LONG_LEN</A></STRONG><DD>
<DT><STRONG><A NAME="item_ASN_EXTENSION_ID">ASN_EXTENSION_ID</A></STRONG><DD>
<DT><STRONG><A NAME="item_ASN_BIT">ASN_BIT</A></STRONG><DD>
</DL>
<P>
<HR>
<H2><A NAME="Debug_Functions">Debug Functions</A></H2>
<DL>
<DT><STRONG><A NAME="item_asn_dump">asn_dump</A></STRONG><DD>
<DT><STRONG><A NAME="item_asn_hexdump">asn_hexdump</A></STRONG><DD>
</DL>
<P>
<HR>
<H1><A NAME="EXPORT_TAGS">EXPORT TAGS</A></H1>
<DL>
<DT><STRONG><A NAME="item__all">:all</A></STRONG><DD>
<P>
All exported functions

<DT><STRONG><A NAME="item__const">:const</A></STRONG><DD>
<P>
ASN_BOOLEAN, ASN_INTEGER, ASN_BIT_STR, ASN_OCTET_STR, ASN_NULL,
ASN_OBJECT_ID, ASN_REAL, ASN_ENUMERATED, ASN_SEQUENCE, ASN_SET,
ASN_PRINT_STR, ASN_IA5_STR, ASN_UTC_TIME, ASN_GENERAL_TIME, ASN_UNIVERSAL,
ASN_APPLICATION, ASN_CONTEXT, ASN_PRIVATE, ASN_PRIMITIVE, ASN_CONSTRUCTOR,
ASN_LONG_LEN, ASN_EXTENSION_ID, ASN_BIT

<DT><STRONG><A NAME="item__debug">:debug</A></STRONG><DD>
<P>
asn_dump, asn_dumphex

<DT><STRONG><A NAME="item__io">:io</A></STRONG><DD>
<P>
asn_recv, asn_send, asn_read, asn_write, asn_get, asn_ready

<DT><STRONG><A NAME="item__tag">:tag</A></STRONG><DD>
<P>
asn_tag, asn_decode_tag, asn_encode_tag, asn_decode_length,
asn_encode_length

</DL>
<P>
<HR>
<H1><A NAME="MAPPING_ASN_1_TO_PERL">MAPPING ASN.1 TO PERL</A></H1>
<P>
Every element in the ASN.1 definition has a name, in perl a hash is used
with these names as an index and the element value as the hash value.

<P>
<PRE>  # ASN.1
  int INTEGER,
  str OCTET STRING
</PRE>
<P>
<PRE>  # Perl
  { int =&gt; 5, str =&gt; &quot;text&quot; }
</PRE>
<P>
In the case of a SEQUENCE, SET or CHOICE then the value in the namespace
will be a hash reference which will be the namespce for the elements with
that element.

<P>
<PRE>  # ASN.1
  int INTEGER,
  seq SEQUENCE {
    str OCTET STRING,
    bool BOOLEAN
  }
</PRE>
<P>
<PRE>  # Perl
  { int =&gt; 5, seq =&gt; { str =&gt; &quot;text&quot;, bool =&gt; 1}}
</PRE>
<P>
If the element is a SEQUENCE OF, or SET OF, then the value in the namespace
will be an array reference. The elements in the array will be of the type
expected by the type following the OF. For example with ``SEQUENCE OF
STRING'' the array would contain strings. With ``SEQUENCE OF SEQUENCE { ...
}'' the array will contain hash references which will be used as namespaces

<P>
<PRE>  # ASN.1
  int INTEGER,
  str SEQUENCE OF OCTET STRING
</PRE>
<P>
<PRE>  # Perl
  { int =&gt; 5, str =&gt; [ &quot;text1&quot;, &quot;text2&quot;]}
</PRE>
<P>
<PRE>  # ASN.1
  int INTEGER,
  str SEQUENCE OF SEQUENCE {
    type OCTET STRING,
    value INTEGER
  }
</PRE>
<P>
<PRE>  # Perl
  { int =&gt; 5, str =&gt; [
    { type =&gt; &quot;abc&quot;, value =&gt; 4 },
    { type =&gt; &quot;def&quot;, value =&gt; -1 },
  ]}
</PRE>
<P>
<HR>
<H2><A NAME="Exceptions">Exceptions</A></H2>
<P>
There are some exceptions where Convert::ASN1 does not require an element
to be named. These are SEQUENCE {...}, SET {...} and CHOICE. In each case
if the element is not given a name then the elements inside the {...} will
share the same namespace as the elements outside of the {...}.

<P>
<HR>
<H1><A NAME="TODO">TODO</A></H1>
<UL>
<LI>
<P>
Decoding of a SET.

<LI>
<P>
Indefinite length encoding

<LI>
<P>
XS implementation.

<LI>
<P>
More documentation.

<LI>
<P>
More tests.

</UL>
<P>
<HR>
<H1><A NAME="AUTHOR">AUTHOR</A></H1>
<P>
Graham Barr &lt;<A HREF="mailto:gbarr@pobox.xom">gbarr@pobox.xom</A>&gt;

<P>
<HR>
<H1><A NAME="COPYRIGHT">COPYRIGHT</A></H1>
<P>
Copyright (c) 2000 Graham Barr &lt;<A
HREF="mailto:gbarr@pobox.com">gbarr@pobox.com</A>&gt; All rights reserved.
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

</BODY>

</HTML>
